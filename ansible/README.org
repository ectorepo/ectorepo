#+TITLE:     Ectorepo: Ansible
#+AUTHOR:    David Conner
#+EMAIL:     aionfork@gmail.com
#+DESCRIPTION: notes
#+PROPERTY: header-args :comments none

The docs are now greppable. I wish I had realized this sooner.

* Snippets

#+begin_quote
Okay, these don't work that well as snippets, but do function well as a reminder
of the API for various Ansible modules -- without having to configure Ansible
LSP or something like that. They're also useful reminders of potential
configuration endpoints for anything that Ansible might configure.

It's better to create custom yasnippets under a single module group. Then
they're easy to distinguish from the autogenerated snippets.
#+end_quote

** Automated Snippet Generation

The repo [[github:memoryleak/AdvancedAnsibleSnippets][memoryleak/AdvancedAnsibleSnippets]] has 7000 ansible snippets and
[[emacsfodder/sublime2yas][emacsfodder/sublime2yas]] wasn't written in python, so it still ... seems to run.

I've only tested a few though. After glancing at the snippet formats for
Sublime, yasnippet, atom and VS Code, they all seem to be based on the same
string substitution format, but have different metadata. There's really no
reason we can't have nice things ... like standardized snippet libraries. One
day, perhaps treesitter would be better for snippets (or at least snippet
extraction)

There's really not much of a point to importing them all at once.

*** Advanced Ansible Snippets Generator

The repo [[github:memoryleak/AdvancedAnsibleSnippetsGenerator][memoryleak/AdvancedAnsibleSnippetsGenerator]] appears to have faculties
for generating snippets from other collections, using some of Ansible's module &
plugin reflection. Installing the deps with =poetry install= and running =make=
then =make build= does generate everything.

The generator constructs Ansible's module path using =module_loader= and
includes collections installed via =ansible-galaxy install -r requirements.txt=.
For each path in =module_path=, it accumulates the plugins with metadata of type
=DocCLI(['ansible snippet generator'])=. Then it attempts to convert them.

It's essentially the same metadata used used for =ansible-doc -s
pfsensible.core.pfsense_aggregate=.

#+begin_src yaml
- name: Manage multiple pfSense firewall aliases, rules, and rule separators, plus interfaces and VLANs
  pfsense_aggregate:
      aggregated_aliases:    # Dict of aliases to apply on the target
      aggregated_interfaces:   # Dict of interfaces to apply on the target
      aggregated_nat_outbounds:   # Dict of nat_outbound rules to apply on the target
      aggregated_nat_port_forwards:   # Dict of nat_port_forward rules to apply
                             # on the target
      aggregated_rule_separators:   # Dict of rule separators to apply on the target
      aggregated_rules:      # Dict of rules to apply on the target
      aggregated_vlans:      # Dict of VLANs to apply on the target
      interface_filter:      # only apply rules and rules separators on those
                             # interfaces (separated by space)
      order_rules:           # rules will be generated following the playbook
                             # order
      purge_aliases:         # delete all the aliases that are not defined into
                             # aggregated_aliases
      purge_interfaces:      # delete all the interfaces that are not defined
                             # into aggregated_int erfaces
      purge_nat_outbounds:   # delete all the nat_outbound rules that are not
                             # defined into aggregated_nat_outbounds
      purge_nat_port_forwards:   # delete all the nat_port_forward rules that
                             # are not defined into aggregated_nat_port_forwards
      purge_rule_separators:   # delete all the rule separators that are not
                               # defined into aggregated_rule_separators
      purge_rules:           # delete all the rules that are not defined into
      purge_vlans:           # delete all the VLANs that are not defined into
                             # aggregated_vlans
#+end_src

I kept wondering where Ansible's =rails generate= functions were. Jesus fucking
christ how do people write this shit?

*** sublime2yas

The =-g= parameter lets you specify a glob like =grafana*.sublime-snippet=.

With the right Bash capture group, you can use the =-G= option to associate
snippets to yas groups, so they don't overload the emacs menu autogeneration.

#+begin_src shell
gem install sublime2yas
mkdir out
sublime2yas --major-mode yaml-mode -o out -d AdvancedAnsibleSnippets
#+end_src

Then, to test in emacs, open some generated files and run =yas-tryout-snippet=

**** By Group

Collections in build

#+begin_src shell
ans_snips=$_ECTO/ansible/snippets/AdvancedAnsibleSnippetsGenerator
ans_build=$ans_snips/build/sublime
snip_collections=()
snip_collections+=$(ls $ans_build | sed -E 's/([0-9a-zA-Z_]+)\.([0-9a-zA-Z_]+)\..*\.sublime-snippet/\1.\2/' | sort | uniq)
echo $snip_collections
#+end_src

#+RESULTS:
: amazon.aws ansible.builtin ansible.netcommon ansible.posix ansible.utils ansible.windows arista.eos awx.awx azure.azcollection become.sublime-snippet block.sublime-snippet check_point.mgmt chocolatey.chocolatey cisco.aci cisco.asa cisco.dnac cisco.intersight cisco.ios cisco.iosxr cisco.ise cisco.meraki cisco.mso cisco.nso cisco.nxos cisco.ucs cloud.common cloudscale_ch.cloud community.aws community.ciscosmb community.crypto community.digitalocean community.dns community.docker community.fortios community.general community.google community.grafana community.hashi_vault community.hrobot community.libvirt community.mongodb community.mysql community.network community.okd community.postgresql community.proxysql community.rabbitmq community.routeros community.sap community.sap_libs community.skydive community.sops community.vmware community.windows community.zabbix containers.podman cyberark.pas dellemc.enterprise_sonic dellemc.openmanage dellemc.os10 dellemc.os6 dellemc.os9 dellemc.powerflex dellemc.unity f5networks.f5_modules fortinet.fortimanager fortinet.fortios frr.frr gluster.gluster google.cloud grafana.grafana hetzner.hcloud hpe.nimble ibm.qradar ibm.spectrum_virtualize infinidat.infinibox infoblox.nios_modules inspur.ispim inspur.sm inventory.sublime-snippet junipernetworks.junos kubernetes.core loop_control.sublime-snippet loop.sublime-snippet lowlydba.sqlserver mellanox.onyx microsoft.ad netapp.aws netapp.azure netapp.cloudmanager netapp.elementsw netapp_eseries.santricity netapp.ontap netapp.storagegrid netapp.um_info netbox.netbox ngine_io.cloudstack ngine_io.exoscale ngine_io.vultr openstack.cloud openvswitch.openvswitch ovirt.ovirt pfsensible.core playbook.sublime-snippet purestorage.flasharray purestorage.flashblade purestorage.fusion sensu.sensu_go splunk.es theforeman.foreman t_systems_mms.icinga_director vmware.vmware_rest vultr.cloud vyos.vyos wti.remote

Transform with collection name as =-G $collection_name=

#+begin_src shell
ans_snips=$_ECTO/ansible/snippets/AdvancedAnsibleSnippetsGenerator
ans_build=$ans_snips/build/sublime
ans_coll=containers.podman
my_snips=yaml-mode
sublime2yas --major-mode yaml-mode -o $my_snips -d $ans_build -g "$ans_coll*.sublime-snippet" -G $ans_coll
#+end_src

Now the yasnippet menu is built so you can click around and explore.

[[file:img/imported-snippets.jpeg]]

*** Removing Tags From Snippets

The following script will remove the tags from the autogenerated snippets:

#+begin_src shell
#!/bin/sh
# pass array as glob
if [ 0 -eq $# ]; then exit 1; else
  for f in $@; do
    # this implicitly silences the output
    # sed -ne '/^  tags:$/q;p' $f
    sed -i -e '/^  tags:$/,$d' $f
  done
fi
#+end_src

The =sublime2yas= gem refuses to output to an absolute path, so you'll probably
end up with multiple copies of the snippets. Anyways, you can diff them:

#+begin_src shell
ls home/myuser/.emacs.g/etc/yasnippet/snippets/yaml-mode/community.general.* |\
    xargs -I \{\} diff \{\} /\{\}
#+end_src

But I don't think you can =fan in= the =xargs= ouptut streams to view the diff
output with less. See note on =xargs= output streams below.

*** Interesting Ansible Snippets

A list of interesting modules, included as an example.

#+name: general-modules-list
#+begin_example shell :results file
cat img/community.general.list
#+end_example

I didn't test this script, but the last command gets about half of what I was
interested in.

#+begin_src shell
ans_snips=$_ECTO/ansible/snippets/AdvancedAnsibleSnippetsGenerator
ans_build=$ans_snips/build/sublime
ans_coll=community.general
ans_tmp=$ans_snips/build/tmp

# move the files to a temp directory
mv $ans_build/$ans_coll* $ans_tmp

# make a list, wildcards don't work though, so you don't get all of them
# there's probably some way around this

cat community.general.list |\
    xargs -I "{}" \
          mv $ans_snips/build/tmp/community.general.\{\}.sublime-snippet build/sublime

#+end_src

Unfortunately, most of these were abbreviations in that list.

Fortunately, dired is a killer app in Emacs. If you're not using dired, you're
not using emacs. Use =% m= to mark files by regexp.

=community.general.\(zpool\|xfs\|idrac\|pip\|nomad\|selinux\|mssql\|lxc\|lxd\).*=

- Then use =R= to move to the other directory.
- Delete all the modules for proprietary products you'll never use without =$$$$=

Conveniently STDERR provides a list ... however xargs sporks those output
streams, I don't really know. Is it one stream? Many streams? No idea. It won't
catch modules like =redis= or =proxmox= though because there were valid matches
... this actually doesn't work well.

There are many of these =%= commands like =% r= which allows you to rename files
with matching groups -- you can't easily do this in Bash, not without a function
or a loop.

** Terraform

And for Terraform, there's [[https://github.com/staticaland/terraform-generate-snippets][staticaland/terraform-generate-snippets]], which
autogenerates snippets from =terraform providers schema -json=
