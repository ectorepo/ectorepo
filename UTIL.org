#+TITLE:     Ectorepo: support
#+AUTHOR:    David Conner
#+EMAIL:     noreply@te.xel.io
#+DESCRIPTION: notes
#+PROPERTY: header-args :mkdirp yes
#+PROPERTY: header-args:sh     :tangle-mode (identity #o555) :mkdirp yes
#+PROPERTY: header-args:python :tangle-mode (identity #o644) :mkdirp yes
#+PROPERTY: header-args:conf   :tangle-mode (identity #o444) :mkdirp yes
#+property: header-args:scheme :tangle-mode (identity #o644) :mkdirp yes

#+begin_src emacs-lisp :eval no :exports none :results none
;; Eval with C-x C-e to disable eval confirmation in this buffer
;; ... or set :eval yes
(setq-local org-confirm-babel-evaluate nil)
#+end_src

* Integration

** Org Notes

*** Running scripts on =$_ECTO= content from =$_REPO=

****** TODO _maybe_ use =.dir-locals.el= for setting =ectoroot= ...

+ This won't work well if this notes repository gets absorbed into
  dcunited001/zettlekasten (even as symlink. or git submodule...)
+ direnv may be confusing as well
+ probably best to avoid the refactor and use the ole =Ctrl-C, Ctrl-V= ...
  (shit) i mean ... yasnippets.

** Automation

It would be nice if some of this were automated -- e.g. identification of sqlite3
databases to facilitate generation of sqlite schema diagrams

* Analysis

*** JSON Schema

* Maintenance
** Repo Tools

*** Manifest

Guix environment in =manifest.scm= must be loaded by =buffer-env.el= for tangling to work.

#+begin_src scheme :tangle manifest.scm :eval no
(use-modules (guix packages)
             (gnu packages android)
             (gnu packages python))

(let ((git-repo-with-path
       (manifest-entry
         (name "git-repo")
         (item git-repo)
         (version "2.4.1") ;most recent version
         (search-paths (list (search-path-specification
                              (variable "PYTHONPATH")
                              (files '("share/git-repo")))
                             (search-path-specification
                              (variable "GUIX_PYTHONPATH")
                              (files '("share/git-repo"))))))))

 (concatenate-manifests (list
                         (manifest
                          (list git-repo-with-path))
                          (packages->manifest
                           (list python)))))
#+end_src

**** Package Transformations

See =options->transformations= for info about [[https://guix.gnu.org/manual/en/html_node/Defining-Package-Variants.html][package variants]].

#+begin_example scheme
(package
  (name "hello-simd")
  ;; ...

  ;; This package may benefit from SIMD extensions so
  ;; mark it as "tunable".
  (properties '((tunable? . #t))))
#+end_example

+ =(tunable ...)=
+ =(with-source "/file/or/url.tar.gz")=
+ or =(with-input...)=
+ or =(with-graft...)=

The last of these enables hacking on source checkouts. To use it with
=git-repo=, create a new package that inherits from the intended package and
replace the =(source...)= declaration with a reference to the project's path in
the sync'd repo superproject. There may be a be a better way to do this: =guix
build --help-transform=.

*** Environment

When running the scripts, prefix them with =guix shell -m manifest.scm -- python
$script=. This is the most consistent way to do this in emacs.

The =buffer-env= package will load the correct environment when commands via
=[C-u] M-!=, but trying to get this to work with =org-babel= requires too much
init.el-specific configuration or unsatisfactory boilerplate. This is mainly an
org-babel problem.

For example, the org-babel header =:python (expand-file-name "bin/python3"
(getenv "GUIX_ENVIRONMENT"))= will give the =GUIX_ENVIRONMENT= used to start
emacs. Other ways to addess include =.env= scripts, which aren't necessarily
portable.

*** Shell Scripts

Grok the general directory structure with =tree -dL 3 .= after submodules have
been modulized

#+begin_src shell :results output :var repoproject="crypto" :dir /data/ecto
cd $repoproject
repo forall  -c 'echo $REPO_LREV $REPO_RREV $REPO_PATH $REPO_PROJECT' | head -n7

echo -n '' # idk. it just be like that sometimes
#+end_src

#+RESULTS:
: 78571a281eb251e75683b345025ed74f8b5c6c54 refs/tags/gnupg-2.2.50 gnupg/gnupg-2.2 gnupg
: 9d302f978bd718a7b477294c2f5b386bea6ca00d refs/heads/STABLE-BRANCH-2-4 gnupg/gnupg-2.4 gnupg
: b39a0298112de853cc7c0833ed1c366330a225ef refs/tags/gnupg-2.5.13 gnupg/gnupg-2.5 gnupg
: d0d9652e402ede5824204cf2a8595a89d8f3f9ff refs/heads/master go/go-ykpiv go-piv/go-ykpiv
: 5a76b44bb2ea34ea4b24a6e295fc0a234f5f0692 refs/heads/master go/piv-go go-piv/piv-go
: f380bc1c902b4dcd2a134eadabdd2ecc5a38e211 refs/heads/dev pki/fpkilint gsa/fpkilint
: 64bbb446efa71a64f5cc23a6be94e58b909a6681 refs/heads/main python/cryptography pyca/cryptography

Available environment variables

| ~REPO_PROJECT~   | unique name of the project                                                                    |
| ~REPO_PATH~      | path relative to client root                                                                  |
| ~REPO_OUTERPATH~ | sub manifest's root path relative to client root                                              |
| ~REPO_INNERPATH~ | path relative to root of sub manifest                                                         |
| ~REPO_REMOTE~    | name of the remote system from manifest.                                                      |
| ~REPO_LREV~      | revision from the manifest, translated to a local tracking branch                             |
| ~REPO_RREV~      | revision from the manifest, exactly as written in manifest.                                   |
| ~REPO_COUNT~     | total number of projects being iterated.                                                      |
| ~REPO_I~         | 1-based iteration count ~REPO_I / REPO_COUNT~ shows progress                                    |
| ~REPO__*~        | extra environment variables, specified by the "annotation" element under any project element. |

+ use =REPO_LREV= if you need to pass the manifest revision to a locally executed
  git command
+ =REPO__*= can be useful for differentiating trees based on user-specific
  criteria, or simply annotating tree details

**** Touch repo roots

This will break as git & repo manipulate the repositories, but having remotely
accurate mtimes helps to hone in on what's recent.

#+name: repoTouchRoots
#+begin_src shell :results output :var repoproject="crypto" :dir /data/ecto
cd $repoproject
repo forall -e -c 'touch -m -d $(git log -1 --format="%ad" --date=iso-strict) .'

echo -n '' # idk. it just be like that sometimes
#+end_src

Doesn't print anything, but it seems to work. =touch= will also appear to change
the =ctime=, which is apparently kinda hard to deal with (probably not but idk)

***** TODO add to a Makefile (and also touch parent directories)
probably needed one a long time ago.... dsakfdhskl. it doesn't run in a
checkout.... and you can't =repo init= to a parent-directory. :(

#+call: repoTouchRoots(repoproject="x.files")

**** Maintain Manifests

Now that deltas are minimal (and XML's are guaranteed to be sorted/uniq), things
like this work.

#+begin_quote
I'm probably getting rid of this this submodules approach later. it's just messy
and no one's consuming these repos.

It's also not so great when signing commits.
#+end_quote

***** Validate

Check status

#+begin_src shell
git submodule foreach "git status -s"
#+end_src

Print gitignores

#+begin_src sh
find . -name .gitignore -type f -print \
    | xargs grep --color=auto -e  '^'

    # | xargs -n1 cat # this doesn't print the filename ... idk
#+end_src

***** Manage submodules

#+begin_quote
Quite a bit of this submodule stuff is a bit unwieldy, requiring manual
intervention. The distinct content and my updates are sparse.
#+end_quote

Pull updates and try to rebase local extant commits not persistified
upstream ... and don't checkout a dangling git reference.

#+begin_src shell
git submodule update --remote --rebase
#+end_src

Map =git stash/pull/pop= across submodules

#+begin_src shell
git submodule foreach "git stash && git pull origin master && git stash pop"
#+end_src

***** List submodules

#+begin_src shell
git config --file=.gitmodules submodule."blender".path
#+end_src

#+RESULTS:
: blender

I'm assuming the next command comports with the previous

#+name: ectorepoModules
#+begin_src shell :results output silent
srepo="$(pwd)"
git submodule foreach --quiet 'echo $(pwd)' | sed -E "s|$srepo/||g" | sort
#+end_src

All the =_remotes.xml= files

#+name: ectorepoRemotesXML
#+begin_src shell :results output silent
find . -mindepth 2 -maxdepth 2 -name "_remotes.xml" | cut -f2- -d'/' | sort
#+end_src

All the directories with =default.xml=

#+name: ectorepoDefaultXML
#+begin_src shell :results output silent
find . -mindepth 2 -maxdepth 2 -name "default.xml" | cut -f2- -d'/' | sort
#+end_src

The subprojects that aren't gitmodules

#+name: ectorepoNonModules
#+begin_src shell :results output silent :var modules=ectorepoModules defxml=ectorepoDefaultXML
comm -2 -3 <(echo $defxml | tr ' ' '\n' | cut -f1 -d'/' | sort) \
   <(echo $modules | tr ' ' '\n' | sort)
#+end_src

****** Misc

Which one sticks out?

#+begin_src shell :results output code :wrap example diff
diff <(find . -mindepth 2 -name "default.xml" | sort | cut -f2- -d'/') \
    <(grep -re _remotes.xml --include="default.xml" * | sort | cut -f1 -d':')
echo
#+end_src

#+RESULTS:
#+begin_example diff
4d3
< basic-sec/default.xml

#+end_example

***** Manage =_remotes.xml=

Consolidate =<remote ... />= nodes from all =_remote.xml= files and compare with the
top-level.

The red is missing from =$_REPO/_remote.xml= ...

+ something weird here: use the =git submodule foreach= below (EDIT: some
  non-module, uncommited repos lacked the remotes...)

#+begin_src shell :results output code :wrap example diff
cat  **/_remotes.xml | grep '<remote' | sort | uniq \
    | diff - <(grep '<remote ' _remotes.xml | sort | uniq)
echo
#+end_src

Again, but only for projects with modules

#+begin_src shell :results output code :wrap example diff :var modules=ectorepoModules
mremotes=$(find $modules -name _remotes.xml)
for m in $mremotes; do
    echo $m
    grep '<remote' $m | sort | uniq \
        | diff - <(grep '<remote ' _remotes.xml | sort | uniq)
done
#+end_src

****** Fan-out Copies of =_remotes.xml=

#+begin_src shell
git submodule foreach "cp ../_remotes.xml _remotes.xml"
#+end_src

Diff for lagging copies of =_remotes.xml= across submodules.

+ Diff outputs non-standard exit codes which breaks these macro commands and
  also org babel blocks.
+ The grep will only show the lines from files changed inside the submodule.
  Just a quick check... There's probably a better way with submodule tooling.

#+begin_src shell
git submodule --quiet foreach "diff ../_remotes.xml _remotes.xml ; echo ''" | grep -e '^>'
echo ' '
#+end_src

#+RESULTS:

****** Check, commit and push submodules

#+begin_src shell
git submodule foreach "git add _remotes.xml"
git status
git submodule foreach "git diff --color" # | less
git submodule foreach "git status" # just to be sure
git submodule foreach "git commit -m 'bump remotes.xml'"
git submodule foreach "git push origin master"

# && add the um modules... todo
#+end_src

Then in magit, add submodule refs, commit to super-duper-project and push

... then pull again maybe (reference copies be on a server with SSH access)
***** And so forth

**** Old Merge =_remotes.xml= Manifests

I'm not sure how to merge patches while dropping file source info. This just
finds and reports all lines not in the top-level manifest.

#+begin_src shell :results output
allremotes=_remotes.xml
subremotes=(*/_remotes.xml)

mergedir=$(mktemp -d)

echo $mergedir

for remote in "${subremotes[@]}";do
    remotename=$(dirname $remote)
    #echo "diff $allremotes $remote > remote.diff"
    diff $allremotes $remote > $mergedir/$remotename.xml
done

cat $mergedir/* | grep -e "^>\s*<remote" | sort | uniq | cut -b2-
#+end_src

#+RESULTS:
#+begin_example
/tmp/tmp.6eUYYdLkTz
   <remote name="framagit" fetch="https://framagit.org"/>
   <remote name="github" fetch="https://github.com"/>
   <remote name="srht_abcdw" fetch="https://git.sr.ht/~abcdw"/>
   <remote name="srht_akagi" fetch="https://git.sr.ht/~akagi"/>
   <remote name="srht_krevedkokun" fetch="https://git.sr.ht/~krevedkokun"/>
   <remote name="srht_michal_atlas" fetch="https://git.sr.ht/~michal_atlas"/>
   <remote name="srht_plattfot" fetch="https://git.sr.ht/~plattfot"/>
   <remote name="srht_sircmpwn" fetch="https://git.sr.ht/~sircmpwn"/>
   <remote name="srht_whereiseveryone" fetch="https://git.sr.ht/~whereiseveryone"/>
#+end_example

**** Commit Missing Remotes

After copying updated =_remotes.xml=

#+begin_src shell :results output

remotefile=_remotes.xml
subremotes=(*/_remotes.xml)
currentdir=$(pwd)

for remote in "${subremotes[@]}"; do
subdir=$(dirname $remote)
cd $subdir
git add $remotefile
# script will quit on first error
# git commit -m "update $remotefile"
cd $currentdir
done
#+end_src

#+RESULTS:

*** Python Scripts

When provided the above manifest, a vanilla =buffer-env= configuration, permits
hacking on the python scripts using commands like:

+ C-c C-p :: run-python
+ C-c C-c :: python-shell-send-buffer

Repo's =XmlManifest= class requires a =repodir= and =manifest_file= path. for
these scripts below, I assume that the script is running from =$_REPO= and that
the manifests are sync'd into =$_ECTO/$project=.

**** Merge Manifests

#+begin_src shell
guix shell -m manifest.scm -- python util/merge_manifests.py
#+end_src

#+RESULTS:

#+begin_src python :tangle util/merge_manifests.py  :tangle-mode (identity #o744) :mkdirp yes
import sys
import os
import glob
from os.path import join

import manifest_xml
#from manifest_xml import *
#from manifest_xml import GitcManifest
#from manifest_xml import XmlManifest, GitcManifest, GitcClient
#from manifest_xml import GitcManifest, RepoClient

ecto_dir = os.environ["_ECTO"]
repo_dir = os.environ["_REPO"]
template = join(repo_dir, "_remotes.xml")

remotes_xml_files = glob.glob("*/_remotes.xml")
repo_names = list(map(lambda p: p.split("/")[0], remotes_xml_files))
ecto_paths = list(map(lambda n: "/".join([ecto_dir,n]), repo_names))

#ecto_manifests = list(map(lambda i: GitcManifest(ecto_paths[i], remotes_xml_files[i]),
#                          range(len(remotes_xml_files))))
ecto_manifests = list(map(lambda i: RepoClient(ecto_paths[i], remotes_xml_files[i]),
                          range(len(remotes_xml_files))))

#print(ecto_manifests[0].remotes)
#repo_remote_xml = GitcManifest(".", "_remotes.xml")
#print(repo_remote_xml.remotes)
print(template)
#+end_src

#+RESULTS:

#+begin_example python

# def output_manifest(file):

# assume that the immediate subdirectories of dir may contain _remotes.xml
# collect these files into a list

# def consolidate_remotes(dir):
# os.walk

print(os.path)
print(__file__)

def main(orig_args):
    print("orig_args:",orig_args)

if __name__ == '__main__':
  main(sys.argv[1:])

#+end_example


** Repo Checkout Tools

*** Fix misbehaving checkouts

Running =repo sync= and cloning too many bundles at once ends up not updating
the =pwd= with checkouts, which makes running manual =repo sync $project= a bit
difficult.

#+name: superproject
#+begin_src emacs-lisp :results replace value
"tensorflow"
#+end_src

#+name: superinclude
#+begin_src emacs-lisp :results replace value
"tensorflow_core.xml"
#+end_src

#+name: projects
#+header:  :var superproject=superproject superinclude=superinclude
#+begin_src sh :results replace output
grep -e '<project' $_REPO/$superproject/$superinclude | sed -E 's/^.*path="(.*)" ref=".*$/\1/'
#+end_src

#+RESULTS: projects
#+begin_example
.allstar
adanet
addons
agents
benchmarks
build
cloud
codelabs
community
compression
custom-op
data-validation
datasets
decision-forests
deepmath
docs
docs-l10n
dtensor-gcp-examples
ecosystem
embedding-projector-standalone
estimator
examples
fairness-indicators
federated
fold
gan
gnn
graphics
haskell
hub
io
java
java-models
java-ndarray
kfac
lattice
lingvo
lucid
mesh
metadata
mlir-hlo
model-analysis
model-card-toolkit
model-optimization
model-remediation
models
networking
neural-structured-learning
nmt
oss-fuzz
playground
privacy
probability
profiler
profiler-ui
quantum
ranking
recommenders
recommenders-addons
runtime
rust
serving
sig-tfjs
similarity
swift-apis
tcav
tensor2tensor
tensorboard
tensorflow
tensorrt
text
tf-build-actions
tfhub.dev
tfjs
tfjs-examples
tfjs-models
tfjs-website
tfjs-wechat
tflite-micro
tflite-micro-arduino-examples
tflite-support
tfx
tfx-addons
tfx-bsl
toolchains
tpu
transform
#+end_example

** Git
